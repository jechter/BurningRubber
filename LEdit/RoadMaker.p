program RoadMaker;	type		LevelFormat = array[0..maxint] of array[1..4] of integer;		LevelPtr = ^LevelFormat;		LevelHandle = ^LevelPtr;	var		Recy: Rect;		Mode, i, before: integer;		Hit, Draw, Liner, Pos, oldpos: Point;		Edit: Levelhandle;		scroll: integer;		Bo, vector: Boolean;		Ev: EventRecord;		lastpt: point;	procedure cleanHandle (fro, till: integer);		var			i: integer;	begin		for i := fro to till do			begin				Edit^^[i][1] := 0;				Edit^^[i][2] := 320;				Edit^^[i][3] := 320;				Edit^^[i][4] := 640;			end;	end;	procedure InsertData (pt: point);	begin		if mode <> 5 then			Edit^^[(600 - pt.v) div 2 + Scroll][mode] := pt.h - 50	end;	function vecfunc: boolean;		type			mptype = packed array[1..128] of boolean;		var			mymap: keymap;	begin		GetKeys(mymap);		vecfunc := mptype(mymap)[37];	end;	function Xfunc: boolean;		type			mptype = packed array[1..128] of boolean;		var			mymap: keymap;	begin		GetKeys(mymap);		xfunc := mptype(mymap)[127];	end;begin	Draw := Point(0);	Scroll := 0;	SetPort(GetNewWindow(128, nil, Pointer(-1)));	SetRect(Recy, 10, 10, 42, 42);	PlotIcon(Recy, GetIcon(128));	SetRect(Recy, 10, 50, 42, 92);	PlotIcon(Recy, GetIcon(129));	SetRect(Recy, 10, 100, 42, 132);	PlotIcon(Recy, GetIcon(130));	SetRect(Recy, 10, 140, 42, 172);	PlotIcon(Recy, GetIcon(131));	SetRect(Recy, 10, 180, 42, 212);	PlotIcon(Recy, GetIcon(132));	SetRect(Recy, 10, 220, 42, 252);	PlotIcon(Recy, GetIcon(133));	SetRect(Recy, 10, 260, 42, 292);	PlotIcon(Recy, GetIcon(134));	SetRect(Recy, 10, 380, 42, 412);	PlotIcon(Recy, GetIcon(137));	MoveTo(50, 0);	LineTo(50, 650);	SetRect(recy, 50, 0, 690, 600);	ClipRect(recy);	Mode := 1;	SetCursor(GetCursor(crosscursor)^^);	Edit := LevelHandle(GetResource('LEVL', 128));	if Edit = nil then		begin			cleanHandle(0, maxint);		end;	Sysbeep(30);	repeat		if button then			begin				getMouse(Hit);				if Hit.h < 50 then					begin						SetRect(Recy, 10, 260, 42, 292);						if ptinrect(Hit, Recy) then							Vector := not Vector;						SetRect(Recy, 10, 10, 42, 42);						if ptinrect(Hit, Recy) then							mode := 1;						SetRect(Recy, 10, 50, 42, 92);						if ptinrect(Hit, Recy) then							mode := 2;						SetRect(Recy, 10, 100, 42, 132);						if ptinrect(Hit, Recy) then							mode := 3;						SetRect(Recy, 10, 140, 42, 172);						if ptinrect(Hit, Recy) then							mode := 4;						SetRect(Recy, 10, 180, 42, 212);						if ptinrect(Hit, Recy) then							begin								scroll := Scroll + 100;								if Scroll > maxint - 600 then									Scroll := maxint - 600;								EraseRect(0, 0, 600, 640);								for i := 0 to 300 do									begin										MoveTo(50, 600 - i * 2);										LineTo(Edit^^[(i + Scroll)][1] + 50, 600 - i * 2);										MoveTo(Edit^^[(i + Scroll)][2] + 50, 600 - i * 2);										LineTo(Edit^^[(i + Scroll)][3] + 50, 600 - i * 2);										MoveTo(Edit^^[(i + Scroll)][4] + 50, 600 - i * 2);										LineTo(690, 600 - i * 2);									end;							end;						SetRect(Recy, 10, 220, 42, 252);						if ptinrect(Hit, Recy) then							begin								scroll := Scroll - 100;								if Scroll < 0 then									Scroll := 0;								EraseRect(0, 0, 600, 640);								for i := 0 to 300 do									begin										MoveTo(50, 600 - i * 2);										LineTo(Edit^^[(i + Scroll)][1] + 50, 600 - i * 2);										MoveTo(Edit^^[(i + Scroll)][2] + 50, 600 - i * 2);										LineTo(Edit^^[(i + Scroll)][3] + 50, 600 - i * 2);										MoveTo(Edit^^[(i + Scroll)][4] + 50, 600 - i * 2);										LineTo(690, 600 - i * 2);									end;							end;						SetRect(Recy, 10, 380, 42, 412);						if ptinrect(Hit, Recy) then							begin								ChangedResource(Handle(Edit));								WriteResource(Handle(Edit));								ExitToShell;							end;					end				else					begin						repeat							if xfunc then								begin									Moveto(hit.h, 0);									Lineto(hit.h, 700);								end;							if button then								begin									GetMouse(Hit);									if not (EqualPt(Draw, Point(0)) or Equalpt(Draw, Hit)) then										begin											moveTo(Hit.h, Hit.v);											LineTo(Draw.h, Draw.v);											if Draw.v < Hit.v then												for i := Draw.v to Hit.v - 1 do													begin														SetPt(Liner, round(((Hit.v - i) / (Hit.v - Draw.v)) * (Draw.h - Hit.h) + Hit.h), i);														InsertData(Liner);													end											else												for i := Hit.v to Draw.v - 1 do													begin														SetPt(Liner, round(((Hit.v - i) / (Hit.v - Draw.v)) * (Draw.h - Hit.h) + Hit.h), i);														InsertData(Liner);													end										end;									InsertData(hit);									Draw := Hit;								end;						until (not button and not vector) or (vector and vecfunc);						SetPt(Draw, 0, 0);						EraseRect(0, 0, 600, 640);						for i := 0 to 300 do							begin								MoveTo(50, 600 - i * 2);								LineTo(Edit^^[(i + Scroll)][1] + 50, 600 - i * 2);								MoveTo(Edit^^[(i + Scroll)][2] + 50, 600 - i * 2);								LineTo(Edit^^[(i + Scroll)][3] + 50, 600 - i * 2);								MoveTo(Edit^^[(i + Scroll)][4] + 50, 600 - i * 2);								LineTo(690, 600 - i * 2);							end;					end;			end		else			begin				Bo := GetNextEvent(everyEvent, Ev);				GetMouse(Pos);				if not Equalpt(Oldpos, Pos) then					EraseRect(0, 50, 20, 200);				MoveTo(50, 15);				DrawString(StringOf('SCR:', (600 - pos.v) div 2 + Scroll, ' LRP:', Pos.h - 50));				oldPos := Pos;				SetCursor(GetCursor(crosscursor)^^);			end;	until False;end.