unit RoadDraw;interface	uses		 Sound, QDOffScreen, Tools, Globals, GameGlobals, GameTools ,		 ToolUtils, Resources;	procedure DoBackground;implementation			procedure DoBackground;		procedure UpdateARect (where: Rect);			const				Factor = 2;					procedure ClearRect (position: Rect);				var					texturerect: rect;			begin				if BitTst(@GamePrefs^^.GrafFlags, 3) then					begin						texturerect := position;						OffSetRect(textureRect, 0, BackScroll+20);						CopyBits(BitMapHandle(GetGWorldPixmap(Backworld))^^, BitMapHandle(GetGWorldPixmap(Screenworld))^^, textureRect, position, srcCopy, nil);					end				else				begin					EraseRect(position);				end;			end;			procedure DrawRoad(Pos:Rect;BotScroll:integer);				procedure MakeLine (fro, tow, V, LLimit, RLimit: integer);					type						X8Ptr=^double;						X4Ptr=^longint;						X2Ptr=^integer;						X1Ptr=^byte;					var		{$IFC POWERPC}	dst:ptr;						count:longint;{$ENDC}				begin					if  (fro <= RLimit) and (tow > LLimit) and (V<462) and (V>=0) and (RLimit <= 620) then						begin							if Fro < LLimit then								fro:=LLimit;							if tow > RLimit then								tow:=RLimit;			{$IFC POWERPC}	if Depth=8 then							begin								count:=tow-fro;								dst:=GetPixBaseAddr(GetGWorldPixMap(Screenworld));								longint(dst):=longint(dst)+BAND(GetGWorldPixMap(Screenworld)^^.rowbytes,$3FFF)*V;								longint(dst):=longint(dst)+fro;								while count>= 8 do									begin										X8Ptr(dst)^:=X8Ptr(RoadColData^)^;										longint(dst):=longint(dst)+8;										count:=count-8;									end;											if count>= 4 then										begin										X4Ptr(dst)^:=X4Ptr(RoadColData^)^;										longint(dst):=longint(dst)+4;										count:=count-4;									end;								if count>= 2 then									begin										X2Ptr(dst)^:=X2Ptr(RoadColData^)^;										longint(dst):=longint(dst)+2;										count:=count-2;									end;								if count > 0 then 									begin										X1Ptr(dst)^:=X1Ptr(RoadColData^)^;										longint(dst):=longint(dst)+1;									end;								longint(dst):=longint(dst)+BAND(GetGWorldPixMap(Screenworld)^^.rowbytes,$3FFF);								count:=tow-fro;								longint(dst):=longint(dst)-count;								while count>= 8 do									begin										X8Ptr(dst)^:=X8Ptr(RoadColData^)^;										longint(dst):=longint(dst)+8;										count:=count-8;									end;											if count>= 4 then									begin										X4Ptr(dst)^:=X4Ptr(RoadColData^)^;										longint(dst):=longint(dst)+4;										count:=count-4;									end;								if count>= 2 then									begin										X2Ptr(dst)^:=X2Ptr(RoadColData^)^;										longint(dst):=longint(dst)+2;										count:=count-2;									end;								if count > 0 then									X1Ptr(dst)^:=X1Ptr(RoadColData^)^;							end								else			{$ENDC}			begin								if fro<tow then begin									RGBForeColor(MyRoad^^.Road);									MoveTo(fro,V);LineTo(tow,V); 									ForeColor(BlackColor);								end;							end;						end;				end;				var					i:integer;			begin				if not BitTst(@MyRoad^^.Flags, 3) then					for i := BotScroll div 2 to (BotScroll+pos.Bottom-Pos.top+1) div 2 do						if (Data^^[i][3] = Data^^[i][2]) then							MakeLine(Data^^[i][1], Data^^[i][4], 480-(i-Scroll)*2, Pos.left, Pos.right)						else							begin								MakeLine(Data^^[i][1], Data^^[i][2], 480-(i-Scroll)*2, Pos.left, Pos.right);								MakeLine(Data^^[i][3], Data^^[i][4], 480-(i-Scroll)*2, Pos.left, Pos.right);							end;			end;		begin			ClearRect(where);			DrawRoad(where,Scroll*2+480-where.bottom);		end;		procedure ScrollBack;			var				ScrollingRect: Rect;		begin			if Scroll <> OldScroll then				begin					SetGWorld(ScreenWorld, nil);					SetRect(ScrollingRect, 0, 0, 620, 480 - (Scroll-OldScroll));					ScrollRect(ScrollingRect,0,(Scroll-OldScroll) *2,nil);					BackScroll := BackScroll - (Scroll - OldScroll)*2;					while BackScroll < -64 do						BackScroll := BackScroll + 64;				end;		end;		procedure UpdateRects;			type				OBJDef = record						icon: Integer;						UD, LR: integer;						Brakes: integer;						Die: integer;						Flags1: Byte;						V, H: integer;						weigth, Crash, Jump, Score: integer;					end;				DefPtr = ^OBJDef;				DefHandle = ^DefPtr;			var				i: integer;				ObRect, IgnoreRect, ScreenRect: Rect;				Def: OBJDef;		begin						PenSize(1, 2);			if not BitTst(@GamePrefs^^.GrafFlags, 3) then 				RGBBackColor(MyRoad^^.Back);						if UDSpeed>= 0 then				SetRect(ObRect, 0, 0, 620,(Scroll-Oldscroll)*2)			else				SetRect(ObRect, 0, 480-70, 620, 480);			UpdateARect(ObRect);			ObRect := CarRect;			OffSetRect(ObRect, 0, (Scroll - OldScroll) * 2);			UpdateARect(ObRect);						if UDSpeed<0 then			begin				SetRect(ObRect, 17, 480 - 85, 81, 480 - 21);				OffSetRect(ObRect, 0, (Scroll - OldScroll) * 2);				UpdateARect(ObRect);			end;			SetRect(ScreenRect, 0, 0, 620, 480 - (Scroll - OldScroll));			for i := 1 to LastObj do				begin					Def := DefHandle(GetResource('ODEF', Items^^[i].ID))^^;					SetRect(ObRect, Items^^[i].LR, -((Items^^[i].Scroll * 2 - Scroll * 2) - 480), Items^^[i].LR + Def.V + 32, -((Items^^[i].Scroll * 2 - Scroll * 2) - 480) + Def.H + 32);					if SectRect(ObRect, Screenrect, IgnoreRect) and ((Iteminfo[i].UD<>0) or (Iteminfo[i].LR<>0) or BitTst(@Def.Flags1,4) ) then						UpdateARect(ObRect);				end;			for i := 1 to 10 do				if animations[i].on then					if SectRect(animations[i].Pos, Screenrect, IgnoreRect) then						UpdateARect(animations[i].Pos);			for i := 1 to 15 do				if not EmptyRect(URects[i]) then					if SectRect(URects[i], Screenrect, IgnoreRect) then						begin							OffSetRect(URects[i], 0, (Scroll - OldScroll) * 2);							UpdateARect(URects[i]);						end;			SetRect(ObRect, BonLR, 480 - (BonPos - Scroll) * 2, BonLR + 24, 480 - (BonPos - Scroll) * 2 + 24);			if SectRect(ObRect, Screenrect, IgnoreRect) then				UpdateARect(ObRect);			if MultiBonus < 0 then				begin					SetRect(ObRect, 620 - 130, 7 + (Scroll - OldScroll) * 2, 620 - 112, 25 + (Scroll - OldScroll) * 2);					UpdateARect(ObRect);				end;			PenSize(1, 1);			BackColor(whiteColor);			ForeColor(BlackColor);		end;	begin		ScrollBack;		UpdateRects;		OldScroll := Scroll;		RectCount := 0;	end;end.